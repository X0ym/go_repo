# 基本并发原语

并发原语包括：

## 临界区和共享资源

临界区就是一个被共享的资源，或者说是一个整体的一组共享资源，
比如对数据库的访问、对某一个共享数据结构的操作、对一个 I/O 设备的使用、对一个连接池中的连接的调用

## 使用场景

- **共享资源**。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。
- **任务编排**。需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。
- **消息传递**。信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。

## 1 Mutex使用

Locker 接口，Mutex实现了 Locker 接口

```
// A Locker represents an object that can be locked and unlocked.
type Locker interface {
	Lock()
	Unlock()
}
```

互斥锁 Mutex 就提供两个方法 Lock 和 Unlock：进入临界区之前调用 Lock 方法，退出临界区的时候调用 Unlock 方法

```
func(m *Mutex)Lock()
func(m *Mutex)Unlock()
```

当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine 就会阻塞在 Lock 方法的调用上，
直到锁被释放并且自己获取到了这个锁的拥有权

注意：Mutex不需要额外的初始化，直接声明变量（如 `var mu sync.Mutex` ）即可

参考

> go 语言查看汇编代码命令:go tool compile -S file.go
> 鸟叔的：sync.mutex 源代码分析: https://colobu.com/2018/12/18/dive-into-sync-mutex/
> golang源码阅读-sync.Mutex: https://studygolang.com/articles/17017

## 2 Mutex实现

Mutex 的实现分为四个阶段

1. 使用一个 flag 表示锁是否被持有
2. 新的 goroutine 尽可能先获取到锁
3. 新的和被唤醒的 goroutine 有更多的机会获取锁（带来了饥饿问题）
4. 解决饥饿问题
